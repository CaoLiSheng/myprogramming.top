<article class="markdown-body antique"><h1>读书习题之《Operating System Concepts》5</h1><h6 class="date-tag"><code> ~-~> 2021-08-31</code></h6><blockquote><p>习题 of CPU 调度</p></blockquote><h2 id="a-cpu-scheduling-algorithm-determines-an-order-for-the-execution-of-its-scheduled-processes-given-n-processes-to-be-scheduled-on-one-processor-how-many-different-schedules-are-possible-give-a-formula-in-terms-of-n">A CPU-scheduling algorithm determines an order for the execution of its scheduled processes. Given n processes to be scheduled on one processor, how many different schedules are possible? Give a formula in terms of n.</h2><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">n!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mclose">!</span></span></span></span> (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>f</mi><mi>a</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>l</mi><mo>=</mo><mi>n</mi><mo>×</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>×</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>×</mo><mn>2</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n factorial = n \times (n-1) \times (n-2) \times ... \times 2 \times 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mord mathnormal">ia</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>).</p><h2 id="explain-the-difference-between-preemptive-and-nonpreemptive-scheduling">Explain the difference between preemptive and nonpreemptive scheduling.</h2><p>Preemptive scheduling allows a process to be interrunpted in the midst of it execution, taking the CPU away and allocating it to another process. Nonpreemptive scheduling ensures that a process relinquishes control of the CPU only when it finishes with its current CPU burst.</p><h2 id="what-advantage-is-there-in-having-different-time-quantum-sizes-at-different-levels-of-a-multilevel-queueing-system">What advantage is there in having different time-quantum sizes at different levels of a multilevel queueing system?</h2><p>Processes that need more frequent servicing —— for instance, interactive processes such as editors —— can be in a queue with a small time quantum. Processes with no need for frequent servicing can be in a queue with a larger quantum, requiring few context switches to complete the processing and thus making more efficient use the computer.</p><h2 id="many-cpu-scheduling-algorithms-are-parameterized-for-example-the-rr-algorithm-requires-a-parameter-to-indicate-the-time-slice-multilevel-feedback-queues-require-paramaters-to-define-the-number-of-queues-the-scheduling-algorithms-for-each-queue-the-criteria-used-to-move-processes-between-queues-and-so-on-these-algorithms-are-thus-really-sets-of-algorithms-for-example-the-set-of-rr-algorithms-for-all-time-slices-and-so-on-one-set-of-algorithms-may-include-another-for-example-the-fcfs-algorithm-is-the-rr-algorithm-with-an-infinite-time-quantum-what-if-any-relation-holds-between-the-following-pairs-of-algorithm-sets">Many CPU-scheduling algorithms are parameterized. For example, the RR algorithm requires a parameter to indicate the time slice. Multilevel feedback queues require paramaters to define the number of queues, the scheduling algorithms for each queue, the criteria used to move processes between queues, and so on. These algorithms are thus really sets of algorithms (for example, the set of RR algorithms for all time slices, and so on). One set of algorithms may include another (for example, the FCFS algorithm is the RR algorithm with an infinite time quantum). What (if any) relation holds between the following pairs of algorithm sets?</h2><h3 id="a-priority-and-sjf">a. Priority and SJF</h3><p>The shortest job has the highest priority.</p><h3 id="b-multilevel-feedback-queues-and-fcfs">b. Multilevel feedback queues and FCFS</h3><p>The lowest level of MLFQ is FCFS.</p><h3 id="c-priority-and-fcfs">c. Priority and FCFS</h3><p>FCFS gives the highest priority to the job that has been in existence the longest.</p><h3 id="d-rr-and-sjf">d. RR and SJF</h3><p>None.</p><h2 id="suppose-that-a-cpu-scheudling-algorithm-favors-those-processes-that-have-used-the-least-processor-time-in-the-recent-past-why-will-this-algorithm-favor-i-o-bound-programs-yet-not-permanently-starve-cpu-bound-programs">Suppose that a CPU scheudling algorithm favors those processes that have used the least processor time in the recent past. Why will this algorithm favor I/O-bound programs yet not permanently starve CPU-bound programs?</h2><p>It will favor the I/O-bound programs because of the relatively short CPU bursts requested by them; however, the CPU-bound programs will not starve, because the I/O-bound programs will relinquish the CPU relatively often to do their I/O.</p><h2 id="distinguish-between-pcs-and-scs-scheduling">Distinguish between PCS and SCS scheduling.</h2><p>PCS scheduling is local to the process. It is how the thread library schedules threads onto available LWPs. SCS scheduling is used when the operating system schedules kernel threads. On systems using either the many-to-many or the many-to-one model, the two scheduling models are fundamentally different. On systems using the one-to-one model, PCS and SCS are the same.</p><hr><h2 id="bi-ji-mu-lu">笔记目录</h2><ol><li><a href="scroll-to-the-very-top">回到开头</a></li></ol><br /><br /><hr /><br /><div class="comments"><a href="mailto:954382491@qq.com?subject=评价「读书习题之《Operating System Concepts》5」">来聊两句吧～</a><h6 class="tip">⚠️ 请先安装一款邮件软件（部分浏览器可能不支持，请使用设备默认浏览器打开本页面）</h6></div><br /></article>