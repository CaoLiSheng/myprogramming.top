<!DOCTYPE html><html lang="cn-zh"><head><meta charset="UTF-8" /><meta http-equiv="pragma" content="no-cache" /><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title>读书笔记之《Java I/O, NIO, and NIO.2》 | 又心真人的博客</title><script> var _hmt = _hmt || []; (function () { var hm = document.createElement('script'); hm.src = 'https://hm.baidu.com/hm.js?f402a68d651d46513a3688a8d07eb93c'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(hm, s); })(); </script><link rel="stylesheet" type="text/css" href="antique.3557d5fb44.css" /></head><body theme="Light" class="snapshot"><div id="main"><article class="markdown-body hidden"><h1>读书笔记之《Java I/O, NIO, and NIO.2》</h1><h6 class="date-tag"><code> ~-~> 2021-01-25</code></h6><h2>IO Basics &amp; APIs</h2><p>I/O is fundamental to operating systems, computer languages, and language libraries. Java supports I/O through its classic I/O, NIO, and NIO.2 API categories.</p><p>Classic I/O provides APIs to access the file system, access file content randomly (as opposed to sequentially), stream byte-oriented data between sources and destinations, and support character streams.</p><p>NIO provides APIs to manage buffers, communicate buffered data over channels, leverage readiness selection via selectors, scan textual data quickly via regular expressions, specify character encodings via charsets, and support printf-style formatting.</p><p>NIO.2 provides APIs to improve the file system interface; support asynchronous I/O; and complete socket channel functionality by upgrading DatagramChannel, ServerSocketChannel, and SocketChannel, and by introducing a new MulticastChannel interface.</p><h2>File</h2><p>The File class provides access to the underlying operating system’s available file system(s). Each File instance stores the abstract path for some file system object. Various File methods (such as void delete()) affect the file system object represented by the abstract path.</p><p>First, learned how to construct File instances. Then, explored methods for obtaining information about stored abstract paths and their files or directories, obtaining a list of roots and disk space, listing directories, creating/modifying files/directories, setting/getting permissions, and more.</p><h2>RandomAccessFile</h2><p>Files can be opened for random access in which a mixture of write and read operations at various locations can occur until the file is closed. Java supports this random access by providing the RandomAccessFile class (in the java.io package).</p><p>First, learned about RandomAccessFile’s constructors, operation modes, and the file pointer. Then, explored a sample of this class’s methods. Next, learned about the FileDescriptor class and its methods. Lastly, learned how to use RandomAccessFile to create a flat file database.</p><h2>Streams</h2><p>Java uses streams to perform I/O operations. A stream is an ordered sequence of bytes of an arbitrary length. Bytes flow over an output stream from an application to a destination and flow over an input stream from a source to an application.</p><p>The java.io package provides several classes that identify various stream destinations and sources. These classes are descendants of the abstract OutputStream and InputStream classes. FileOutputStream and BufferedInputStream are examples.</p><p>Explored OutputStream and InputStream, followed by the byte array, file, piped, filter, buffered, data, object, and print streams. While covering object streams, it introduced the topics of serialization and externalization. Concluded by revisiting standard I/O.</p><p><figure><div class="image" style="height: auto;" data-scroll-x="0" data-scroll-y="0"><img alt="Overviews" src="../resources/Book-Java-IO-NIO-NIO2/Streams.png" title="又心真人的博客" width="666px" height="auto" /></div><figcaption>Overviews</figcaption></figure></p><p>Tell the serialization and deserialization mechanisms to serialize or deserialize the object’s normal state before serializing or deserializing additional data items by first calling ObjectOutputStream’s defaultWriteObject() method in writeObject(ObjectOutputStream) or by first calling ObjectInputStream’s defaultReadObject() method in readObject(ObjectInputStream).</p><h2>Writers and Readers</h2><p>Java’s stream classes are good for streaming sequences of bytes, but they’re not good for streaming sequences of characters because bytes and characters are two different things. A byte represents an 8-bit data item and a character represents a 16-bit data item. Also, Java’s char and String types naturally handle characters instead of bytes. More importantly, byte streams have no knowledge of character sets and their encodings.</p><p>Java provides writer and reader classes to stream characters. They support character I/O (they work with char instead of byte) and take character encodings into account. The abstract Writer and Reader classes describe what it means to be a writer and a reader.</p><p>Writer and Reader are subclassed by OutputStreamWriter and InputStreamReader, which bridge the gap between character and byte streams. These classes are subclassed by the FileWriter and FileReader convenience classes, which facilitate writing/reading characters to/from files. Writer and Reader are also subclassed by BufferedWriter and BufferedReader, which buffer characters for efficiency.</p><p><figure><div class="image" style="height: auto;" data-scroll-x="0" data-scroll-y="0"><img alt="Overviews" src="../resources/Book-Java-IO-NIO-NIO2/Writers&Readers.png" title="又心真人的博客" width="666px" height="auto" /></div><figcaption>Overviews</figcaption></figure></p><h2>Buffers</h2><p>A buffer is an NIO object that stores a fixed amount of data to be sent to or received from an I/O service. It sits between an application and a channel that writes the buffered data to the service or reads the data from the service and deposits it into the buffer.</p><p>Buffers possess capacity, limit, position, and mark properties. These four properties are related as follows: 0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity.</p><p>Buffers are implemented by abstract classes that derive from the abstract Buffer class. These classes include ByteBuffer, CharBuffer, DoubleBuffer, FloatBuffer, IntBuffer, LongBuffer, and ShortBuffer. Furthermore, ByteBuffer is subclassed by the abstract MappedByteBuffer class.</p><p>In this chapter, learned how to create buffers (including view buffers), write and read buffer contents, flip buffers, mark buffers, and perform additional operations on buffers such as compaction. Also learned about byte ordering and direct byte buffers.</p><br /><br /><hr /><br /><div class="comments"><a href="mailto:954382491@qq.com?subject=评价「读书笔记之《Java I/O, NIO, and NIO.2》」">来聊两句吧～</a><h6 class="tip">⚠️ 请先安装一款邮件软件（部分浏览器可能不支持，请使用设备默认浏览器打开本页面）</h6></div><br /></article></div><script type="application/javascript" src="template.003be6439b.js"></script></body></html>