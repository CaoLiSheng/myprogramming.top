<!DOCTYPE html><html lang="cn-zh"><head><meta charset="UTF-8" /><meta http-equiv="pragma" content="no-cache" /><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title>读书笔记之《Algorithms》10</title><script> var _hmt = _hmt || []; (function () { var hm = document.createElement('script'); hm.src = 'https://hm.baidu.com/hm.js?f402a68d651d46513a3688a8d07eb93c'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(hm, s); })(); </script><link rel="stylesheet" type="text/css" href="antique.bffd3390e9.css" /></head><body theme="Light" class="snapshot"><div id="main"><article class="markdown-body hidden"><h1>读书笔记之《Algorithms》10</h1><h6 class="date-tag"><code> ~-~> 2020-11-20</code></h6><blockquote><p>Maximum Flows &amp; Minimum Cuts（最大流量和最小切割）</p></blockquote><h2 id="定义">定义</h2><p>给定（Fix）一个<strong>有向加权图</strong>，以及一对起点（s）和终点（t），权重代表该边所能承载的最大速率。 最大流量问题就是求物资（假设的）从 s 运送到 t 的最大速率。 最小切割问题就是求最小的代价（删图中的边）使得无法从 s 运送物资到 t。</p><blockquote><p>书上最开始举的例子是美国从军事角度对俄罗斯铁路网的研究，所以才有了物资这个假设。</p></blockquote><h3 id="流量">流量</h3><ul><li>(s,t)-flow：一个函数，通常记作 <code>f:E-&gt;R</code>，R 的部分又记作 <code>|f|</code>，含义是起点的流出量（有点净流出量的意思）： <code>|f|</code> = sum({f(<code>s-&gt;w</code>)|<code>s-&gt;w</code> in E}) - sum({f(<code>u-&gt;s</code>)|<code>u-&gt;s</code> in E})</li><li>满足的流量守恒定律：sum({f(<code>u-&gt;v</code>)|<code>u-&gt;v</code> in E}) = sum({f(<code>v-&gt;w</code>)|<code>v-&gt;w</code> in E})（s,t 可能不满足该定律，其它节点 v 都是满足的）</li><li>任一点流量：@f(v) = sum({f(<code>v-&gt;w</code>)|<code>v-&gt;w</code> in E}) - sum({f(<code>u-&gt;v</code>)|<code>u-&gt;v</code> in E})（净输出｜增益）</li><li>所有节点的流量：sum({@f(v)|v in V}) = @f(s) + @f(t)，因为其余点满足守恒定律值为零； 另外，所有节点的流量之和应当为零，因为从 s 流出的物资必定全部送达 t，所以@f(s) = -@f(t)</li><li>容量函数：通常记作 <code>c:E-&gt;R,R&gt;=0</code>，当 <code>0&lt;=f(e)&lt;=c(e)</code> 时，称 f 是可行的（feasible）； 当 <code>f(e)==c(e)</code> 时，称 f 饱和（saturate）使用 e； 当 <code>f(e)==0</code> 时，称 f 避免（avoid）使用 e</li><li>最大流量问题：在给定的图和容量函数中计算一个尽可能大的 <code>(s,t)-flow</code> 的值</li></ul><h3 id="切割（截流）">切割（截流）</h3><ul><li>(s,t)-cut：一次拆分，把图中所有节点分成不相交的两个子集 S、T，s in S、t in T</li><li>切分的破坏量：<code>||S,T|| = sum({c(v-&gt;w)|v in S,w in T,v-&gt;w in E})</code></li><li>最小代价截流问题：在给定的图和容量函数中计算一个尽可能小的 <code>(s,t)-cut</code> 的破坏量</li></ul><h3 id="二者的联系">二者的联系</h3><blockquote><p>给定（Fix）任一可行的 flow 和 cut，<code>f &lt;= ||S,T||</code>。当且仅当 flow <code>saturate</code> 每一条 S 到 T 的边，<code>avoid</code> 每一条 T 到 S 的边 时，<code>f == ||S,T||</code>。</p></blockquote><figure><div class="image" style=" height: auto;"><img alt="证明过程" src="../resources/Algorithms-10-Maximum-Flows-&-Minimum-Cuts/flow-cut-bouncing-inequalities.png" title="证明过程" width="700px" height="auto" /></div><figcaption>证明过程</figcaption></figure><p>更进一步，若 <code>f == ||S,T||</code>，则 f 为最大流量，(S,T) 为最小代价切割。</p><blockquote><p>在所有的流网络中，给定（Fix）source s、target t，最大流量 <strong>等于</strong> 最小切割破坏量（就像是中间有个独木桥似的）。</p></blockquote><h2 id="ford-and-fulkerson’s-augmenting-path-algorithm">Ford and Fulkerson’s augmenting-path algorithm</h2><p>基于最大流量和最小切割的联系，<code>Ford and Fulkerson</code> 给出了一个算法，虽然只能用于容量是整数的场景，由于其从 0 开始迭代，假如最终最大流量是 <code>f*</code>，那么该算法可能需要迭代 <code>f*</code> 次。 然而，排除了特殊情况后，每次迭代都会增加 <code>min(cf(u-&gt;v)|u-&gt;v in Ef)</code>，<code>Ef</code>为上次迭代后 G 的容量剩余 Gf。</p><pre><code class="python language-python">def FordFulkersonMethod(G,s,t):
  initialize flow f to 0
  while there exists an augmenting path p in the residual network Gf:
    augment flow f along p # 不断增加总流量，虽然在某些边上可能是减少
  return f
</code></pre><h2 id="流的组合与分解">流的组合与分解</h2><p>通过研究流的分解（实际上是上面算法的逆过程）的性质，<code>Ford and Fulkerson</code> 的算法复杂度为 <code>Ω(VE)</code>（渐近下界，换句话说前人后辈们的努力目标）。</p><h2 id="计算增广路径（augmenting-path）">计算增广路径（augmenting path）</h2><p>类似 <code>Whatever-First Search</code>，计算增广路径的方法有：</p><ol><li>深度优先，容易陷入死循环，且在容量为实数范围时不能收敛至正确解</li><li>最快增广，确保每次增加的流量都是最大的，用到了优先队列，不过容量为实数时同样失效，幸好可以收敛至正确解</li><li>最短增广，完美～！</li></ol><h2 id="书中的典型案例">书中的典型案例</h2><p>（陆续完善……）</p><h2 id="书中习题">书中习题</h2><p>（陆续完善……）</p><h2 id="同一本书的文章集">同一本书的文章集</h2><ol start="0"><li><a href="post:Book-Algorithms-0-Preface-&-Introduction">Preface-&-Introduction</a></li><li><a href="post:Book-Algorithms-1-Recursion">Recursion</a></li><li><a href="post:Book-Algorithms-2-Backtracking">Backtracking</a></li><li><a href="post:Book-Algorithms-3-Dynamic-Programming">Dynamic Programming</a></li><li><a href="post:Book-Algorithms-4-Greedy-Algorithms">Greedy Algorithms</a></li><li><a href="post:Book-Algorithms-5-Basic-Graph-Algorithms">Basic Graph Algorithms</a></li><li><a href="post:Book-Algorithms-6-Depth-First-Search">Depth-First Search</a></li><li><a href="post:Book-Algorithms-7-Minimum-Spanning-Trees">Minimum Spanning Trees</a></li><li><a href="post:Book-Algorithms-8-Shortest-Paths">Shortest Paths</a></li><li><a href="post:Book-Algorithms-9-All-Pairs-Shortest-Paths">All-Pairs Shortest Paths</a></li><li><a href="scroll-to-the-very-top">回到开头</a></li><li><a href="post:Book-Algorithms-11-Applications-of-Flows-and-Cuts">Applications of Flows and Cuts</a></li><li><a href="post:Book-Algorithms-12-NP-Hardness">NP-Hardness</a></li></ol><br /><br /><hr /><br /><div class="comments"><a href="mailto:954382491@qq.com?subject=评价「读书笔记之《Algorithms》10」">发邮件～来聊两句吧～</a><h6 class="tip">⚠️ 请先安装一款邮件软件（部分浏览器可能不支持，请使用设备默认浏览器打开本页面）</h6></div><br /></article></div><script type="application/javascript" src="template.48f2656a3a.js"></script></body></html>