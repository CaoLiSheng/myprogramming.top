<!DOCTYPE html><html lang="cn-zh"><head><meta charset="UTF-8" /><meta http-equiv="pragma" content="no-cache" /><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title>读书笔记之《Algorithms》2</title><script> var _hmt = _hmt || []; (function () { var hm = document.createElement('script'); hm.src = 'https://hm.baidu.com/hm.js?f402a68d651d46513a3688a8d07eb93c'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(hm, s); })(); </script><link rel="stylesheet" type="text/css" href="antique.403e172c4398ada09dfe.css" /></head><body class="snapshot"><article class="markdown-body hidden"><h1>读书笔记之《Algorithms》2</h1><h6 class="date-tag"><code> ~~ 更新时间 -> 2020-10-08 09:00:00</code></h6><blockquote><p>Recursion</p></blockquote><h2 id="reduction">Reduction（降低复杂度技术）</h2><p>例如，<code>Congressional Apportionment 问题</code> 中 <code>ApportionCongress</code> 算法将问题转化为对 <code>优先队列</code> 的 <code>插入</code> 和 <code>弹出最大优先项</code> 的操作。<code>优先队列</code> 对 <code>ApportionCongress</code> 算法来说是个黑箱，后者无需关心前者的正确性，然而选择合适的实现会影响算法的运行效率，这正是算法分析中的 <code>Why</code> 和 <code>How Fast</code>。</p><h2 id="recursionreduction">Recursion（递归，一种特殊的 Reduction）</h2><ol><li>如果，能直接得到解，则直接解（Base Case）</li><li>否则，将问题拆分为一个或多个更简单的相同的问题（Reduction）</li></ol><h2 id="patterndivideconquer">Pattern（Divide &amp; Conquer）</h2><ol><li>Divide：把给定的一个规模较大问题分解为一个或多个规模较小的相同问题</li><li>Delegate：指定每个小问题调用递归方式求解</li><li>Combine：将每个小问题的解整合起来作为给定问题的解</li></ol><h2 id="recursiontrees">Recursion Trees</h2><p>递归式 <code>T(n)=rT(n/c)+f(n)</code> 的递归树结构可以描述为：共 <code>L=log(c)(n)</code> 层，第 <code>l</code> 层 <code>pow(r, l)</code> 个节点，用时 <code>T'(l)=pow(r, l)*f(n/pow(c, l))</code>，总用时 <code>T(n)=T'(0)+T'(1)+ .. +T'(L)</code>。</p><p>计算总用时，有三种特殊情况：</p><ol><li><code>T'(l)</code> 随着 <code>l</code> 从 <code>0</code> 到 <code>L</code> 呈 <code>指数级减小</code>，则 <code>T(n)=O(T'(0))=O(f(n))</code></li><li><code>T'(l)</code> 随着 <code>l</code> 从 <code>0</code> 到 <code>L</code> 呈 <code>指数级相等</code>，则 <code>T(n)=O(f(n)*L)=O(f(n)*log(c)(n))</code></li><li><code>T'(l)</code> 随着 <code>l</code> 从 <code>0</code> 到 <code>L</code> 呈 <code>指数级增加</code>，则 <code>T(n)=O(T'(L))=O(pow(r, log(c)(n))*f(n0))=O(pow(n, log(c)(r)))</code></li></ol><h2 id="">同一本书的文章集</h2><ol><li><a href="post:Algorithms-1-Preface-&-Introduction">Preface-&-Introduction</a></li></ol><br /><br /><hr /><br /><div class="comments"><a href="mailto:954382491@qq.com?subject=评价「读书笔记之《Algorithms》2」">发邮件~来评价~一下吧</a><h6 class="tip">⚠️ 请先安装一款邮件软件（部分浏览器可能不支持，请使用设备默认浏览器打开本页面）</h6></div><br /></article><script type="application/javascript" src="template.94937c92d92ff9ae9b50.js"></script></body></html>