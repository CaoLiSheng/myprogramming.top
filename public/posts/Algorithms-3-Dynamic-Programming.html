<!DOCTYPE html><html lang="cn-zh"><head><meta charset="UTF-8" /><meta http-equiv="pragma" content="no-cache" /><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title>读书笔记之《Algorithms》3</title><script> var _hmt = _hmt || []; (function () { var hm = document.createElement('script'); hm.src = 'https://hm.baidu.com/hm.js?f402a68d651d46513a3688a8d07eb93c'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(hm, s); })(); </script><link rel="stylesheet" type="text/css" href="antique.e3766af187.css" /></head><body class="snapshot"><article class="markdown-body hidden"><h1>读书笔记之《Algorithms》3</h1><h6 class="date-tag"><code> ~~ 更新于 -> 2020-10-27</code></h6><blockquote><p>Dynamic Programming（动态规划）</p></blockquote><h2 id="">第一个简单的动态规划算法</h2><p>大学时没上过课，都是闷着自学的；把好多问题都想复杂了，原来用 for 循环迭代填充斐波那契数组就是一个动态规划算法。</p><h3 id="ologn">结合快速求解矩阵幂运算（O(log(n))）计算斐波那契数</h3><figure><img alt="figure 1: 结合快速求解矩阵幂运算（O(log(n))）计算斐波那契数" src="../resources/Algorithms-3-Dynamic-Programming/formula-fabnacci.png" title="figure 1: 结合快速求解矩阵幂运算（O(log(n))）计算斐波那契数" width="200px" height="auto" /><figcaption>figure 1: 结合快速求解矩阵幂运算（O(log(n))）计算斐波那契数</figcaption></figure><p>重点就在左边矩阵的 n 次幂上！通过递归可以将矩阵乘法的次数降到 log(n) 次（第一章中提供了两种两数相乘的参考算法，均用到递归思想）。实际上，迭代用到的基本运算是加法（O(n)，n 为数字位数），而矩阵运算中使用了更为昂贵的乘法（目前最快的两数字乘法运算的时间复杂度为 O(n log(n)，n 为数字位数)，发现于 2019 年）；所不同的是迭代的循环次数为 n，而计算矩阵的幂的递归次数为 log(n)；所以，这个递归算法比迭代算法快一丢丢，时间复杂度为（Ω(n)，理由是 O(n log(n) log(n)) &lt; O(n^2)，如下图所示）。</p><figure><img alt="迭代算法 vs. 递归算法" src="../resources/Algorithms-3-Dynamic-Programming/iterator-vs-recursive-fabnacci.png" title="迭代算法 vs. 递归算法" /><figcaption>迭代算法 vs. 递归算法</figcaption></figure><p>那么接下来在设计递归算法之前，还需要若干步推导。从 <code>figure 1</code> 看出，我们要设计一个函数，返回值可以是一个元组 <code>(F(n-1), F(n))</code>；递归式可以设计为 <code>T(n) = T(n/2) + O(n)</code>，这样效率最高。有了目标，<code>n/2</code> 是特殊情况，不妨从普通情况开始推导：</p><p>首先，这个算法还有一种行向量的表达方式： <img alt="结合快速求解矩阵幂运算（O(log(n))）计算斐波那契数" src="../resources/Algorithms-3-Dynamic-Programming/formula-fabnacci-0.png" title="结合快速求解矩阵幂运算（O(log(n))）计算斐波那契数" width="300px" height="auto" /> ，另外幂运算的特点是 <img alt="矩阵幂运算的特点" src="../resources/Algorithms-3-Dynamic-Programming/formula-fabnacci-1.png" title="矩阵幂运算的特点" width="300px" height="auto" /> 。所以，可以得到 F(n)的计算公式：</p><figure><img alt="figure 2: F(n)的计算公式" src="../resources/Algorithms-3-Dynamic-Programming/formula-fabnacci-2.png" title="figure 2: F(n)的计算公式" width="500px" height="auto" /><figcaption>figure 2: F(n)的计算公式</figcaption></figure><p>有了 <code>figure 2</code> 中这个重要公式后，我们分别假设 <code>n=2t-1,m=t-1</code> 和 <code>n=2t,m=t</code>，得到：</p><figure><img alt="figure 3: (F(2t-1), F(2t))的计算公式" src="../resources/Algorithms-3-Dynamic-Programming/formula-fabnacci-3.png" title="figure 3: (F(2t-1), F(2t))的计算公式" width="500px" height="auto" /><figcaption>figure 3: (F(2t-1), F(2t))的计算公式</figcaption></figure><p>好了，公式部分到此为止，接下来就是代码实现：</p><pre><code class="python language-python"># F(n-1), F(n)
def FastRecFibo(n):
    if n == 0:
        return 1, 0
    if n == 1:
        return 0, 1

    m = math.floor(n / 2)
    hprv, hcur = FastRecFibo(m)         # F(m-1), F(m)

    prev = hprv * hprv + hcur * hcur    # F(2m-1)
    curr = hcur * (hprv + hprv + hcur)  # F(2m)
    next = prev + curr                  # F(2m+1)

    if n % 2 == 0:
        return prev, curr
    else:
        return curr, next
</code></pre><h2 id="-1">书中的典型案例</h2><ul><li>求斐波那契数</li></ul><p>（陆续完善……）</p><h2 id="-2">书中习题</h2><p>（陆续完善……）</p><h2 id="-3">同一本书的文章集</h2><ol><li><a href="post:Algorithms-0-Preface-&-Introduction">Preface-&-Introduction</a></li><li><a href="post:Algorithms-1-Recursion">Recursion</a></li><li><a href="post:Algorithms-2-Backtracking">Backtracking</a></li><li><a href="scroll-to-the-very-top">回到开头</a></li></ol><br /><br /><hr /><br /><div class="comments"><a href="mailto:954382491@qq.com?subject=评价「读书笔记之《Algorithms》3」">发邮件~来评价~一下吧</a><h6 class="tip">⚠️ 请先安装一款邮件软件（部分浏览器可能不支持，请使用设备默认浏览器打开本页面）</h6></div><br /></article><script type="application/javascript" src="template.5436cf3da0.js"></script></body></html>