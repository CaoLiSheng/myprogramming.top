<!DOCTYPE html><html lang="cn-zh"><head><meta charset="UTF-8" /><meta http-equiv="pragma" content="no-cache" /><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title>JS 模块化 | 又心真人的博客</title><script> var _hmt = _hmt || []; (function () { var hm = document.createElement('script'); hm.src = 'https://hm.baidu.com/hm.js?f402a68d651d46513a3688a8d07eb93c'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(hm, s); })(); </script><link rel="stylesheet" type="text/css" href="github.f39ab1460a.css" /></head><body theme="Light" class="snapshot"><div id="main"><article class="markdown-body hidden"><h1>JS 模块化</h1><h6 class="date-tag"><code> ~-~> 2021-03-31</code></h6><blockquote><h2 id="common-js-amd-umd-cmd-es-modules-jian-jie">CommonJS，AMD，UMD，CMD，ES Modules 简介</h2><h5 id="qi-zhong-umd-common-js-amd">其中 UMD = CommonJS + AMD。</h5><h5 id="common-js-cai-yong-tong-bu-jia-zai-mo-kuai-amd-cai-yong-yi-bu-jia-zai-mo-kuai">CommonJS 采用同步加载模块，AMD 采用异步加载模块。</h5><h5 id="amd-tui-chong-yi-lai-qian-zhi-ti-qian-zhi-xing-cmd-tui-chong-yi-lai-jiu-jin-yan-chi-zhi-xing">AMD 推崇依赖前置、提前执行，CMD 推崇依赖就近、延迟执行。</h5><h5 id="ran-er-cmd-zao-jiu-liang-liang-esm-shi-java-script-guan-fang-de-biao-zhun-hua-mo-kuai-xi-tong">然而 CMD 早就凉凉，ESM 是 JavaScript 官方的标准化模块系统。</h5></blockquote><h2 id="common-js-de-zhi-kao-bei-vs-esm-de-zhi-de-yin-yong">CommonJS 的值拷贝 VS. ESM 的值的引用</h2><ul><li>CommonJS 的执行（动态加载）主要有以下两个特点 <ul><li>CommonJS 模块中 require 引入模块的位置不同会对输出结果产生影响，并且会生成值的拷贝</li><li>CommonJS 模块重复引入的模块并不会重复执行，再次获取模块只会获得之前获取到的模块的缓存</li></ul></li><li>关于 ES6 模块编译时执行（静态编译）会导致有以下两个特点 <ul><li>import 命令会被 JavaScript 引擎静态分析，优先于模块内的其他内容执行</li><li>export 命令会有变量声明提前的效果</li></ul></li></ul><h3 id="dong-tai-jia-zai-vs-jing-tai-bian-yi">动态加载 VS. 静态编译</h3><ul><li>动态加载 <ul><li>只有当模块运行后，才能知道导出的模块是什么</li></ul></li><li>静态编译（JIT） <ul><li>在编译阶段就能知道导出什么模块</li></ul></li></ul><h2 id="tree-shaking">Tree Shaking</h2><p>其原理是<strong>打包工具</strong>对代码做<strong>静态分析</strong>，所以 ESM 是合理的选择。 import (from) 后必须是普通字符串（不含变量），所以打包时就可以确定导入的内容；export 同理。</p><h3 id="lodash-vs-lodash-es">lodash VS. lodash-es</h3><p>两者是 lodash 项目的两个分发版，<a href="https://github.com/lodash/lodash/tree/npm">npm 分支</a> VS. <a href="https://github.com/lodash/lodash/tree/es">es 分支</a>。 前者不能像后者那样被打包工具 tree shaking，它把所有工具函数封装到了一个函数上下文中；后者采用 ESM。 但是不是说所有采用 ESM 的代码都能被 tree shaking。 假如，你把一大坨东西都写到一个类里，命名“工具类”；这就是个反例了。 典型如 lodash 也是这么理解。</p><br /><br /><hr /><br /><div class="comments"><a href="mailto:954382491@qq.com?subject=评价「JS 模块化」">来聊两句吧～</a><h6 class="tip">⚠️ 请先安装一款邮件软件（部分浏览器可能不支持，请使用设备默认浏览器打开本页面）</h6></div><br /></article></div><script type="application/javascript" src="template.077ef0522d.js"></script></body></html>