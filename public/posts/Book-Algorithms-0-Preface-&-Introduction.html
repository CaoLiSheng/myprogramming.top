<!DOCTYPE html><html lang="cn-zh"><head><meta charset="UTF-8" /><meta http-equiv="pragma" content="no-cache" /><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title>读书笔记之《Algorithms》0</title><script> var _hmt = _hmt || []; (function () { var hm = document.createElement('script'); hm.src = 'https://hm.baidu.com/hm.js?f402a68d651d46513a3688a8d07eb93c'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(hm, s); })(); </script><link rel="stylesheet" type="text/css" href="antique.bffd3390e9.css" /></head><body theme="Light" class="snapshot"><div id="main"><article class="markdown-body hidden"><h1>读书笔记之《Algorithms》0</h1><h6 class="date-tag"><code> ~-~> 2020-10-01</code></h6><blockquote><p>Preface-&amp;-Introduction</p></blockquote><h2 id="习题分类">习题分类</h2><ul><li>红心：非常有挑战性的题目，有些就是博士学位资格考试题；一小部分非常有挑战性的题目用大号红心标记</li><li>蓝钻：需要书中后面章节的知识</li><li>绿草花：需要这本书之外的知识</li><li>黑桃：需要大量的繁重的工作或者编码；这类题目很少</li><li>橘星星：十分简单吧</li></ul><h2 id="算法组成">算法组成</h2><ul><li>描述<ul><li>What：算法所解决的问题的精确地说明</li><li>How：算法本身的精确地描述（伪代码）</li></ul></li><li>分析<ul><li>Why：证明算法有效的推导过程</li><li>How fast：对算法运行时间的分析</li></ul></li></ul><blockquote><p><em>作为算法设计师的主要工作是教别人如何以及为什么你的算法起作用。</em></p></blockquote><h2 id="congressional-apportionment-问题">Congressional Apportionment 问题</h2><blockquote><p>这里不是原文，大意是：每个州的议员数量与州人口有关，不能超过每 3 万一个，同时每个州至少一名议员……</p></blockquote><p>这里有两个算法，以及相关的 4 个问题，最后是我个人提供的解答。</p><ol><li>Huntington-Hill method（method of equal proportions）</li></ol><pre><code class="python language-python">ApportionCongress(Pop[1 .. n],R):
  PQ &lt;- NewPriorityQueue
  // Give every state its first representative
  for s &lt;- 1 to n
    Rep[s] &lt;- 1
    Insert(PQ, s, Pop[i]/sqrt(2))

  // Allocate the remaining n-R representatives
  for i &lt;- 1 to n-R
    s &lt;- ExtractMax(PQ)
    Rep[s] &lt;- Rep[s] + 1
    priority &lt;- Pop[s]/sqrt(Rep[s]*(Rep[s]+1))
    Insert(PQ, s, priority)

  return Rep[1 .. n]
</code></pre><ol start="2"><li>Huntington-Hill Guess</li></ol><pre><code class="python language-python">HHGuess(Pop[1 .. n],D):
  reps &lt;- 0
  for i &lt;- 1 to n
    q &lt;- Pop[i]/D
    if q * q &lt; floor(q) * ceil(q)
      Rep[i] &lt;- floor(q)
    else
      Rep[i] &lt;- ceil(q)
    reps &lt;- reps + Rep[i]
  return reps
</code></pre><p>以下是问题以及我提供的个人解答（P 为总人口数）：</p><ol><li>针对算法 2， Show that「标准的 <code>D &lt;- N/R</code> 不一定得到正确解」。</li></ol><p>思路：首先什么是正确解，即 HHGuess 返回值不等于 R；其次这里不需要证明，只需举出一个例子就行。那么可以捏造一个极端的例子：n 个州，只有一个州具有 N 个人口，其它州人口数都为 0；这时 <code>D &lt;- N/R</code>，<code>reps = (n-1)+N/D = R+n-1 &gt; R</code>；可见这样 <code>reps != R</code>，完成！</p><ol start="2"><li>针对算法 2，取两个不同数字作为 <code>D</code> 和 <code>D‘</code>，如果返回的 <code>reps</code> 相等，则 <code>Rep[1 .. N]</code> 也相同。</li></ol><p>思路：分析题意，要想「 <code>reps</code> 相等， <code>Rep[1 .. N]</code> 也相同」，就必须在 <code>D</code> 变化时，有的 <code>q</code> 变大，有的 <code>q</code> 变小。但是，从 <code>q &lt;- Pop[i]/D</code> 看来，<code>q</code> 随 <code>D</code> 的变化是单调递减的。所以，假设中的情况不可能发生；然而，确实存在不同的 <code>D</code> 计算出相同的 <code>reps</code> 的情况；进而证明完成！</p><ol start="3"><li>证明：假如算法 2 计算得到正确的 <code>reps==R</code>，那么 <code>Rep[1 .. n]</code>与算法 1 在相同参数下的计算结果相同。</li></ol><p>思路：算法 1 中的 <code>R</code> 参数来自算法 2 的结果 <code>reps</code>，说明 <code>floor(Pop[i]/D)&lt;=Rep[i]&lt;=ceil(Pop[i]/D)</code>；</p><p>且算法 1 中的 <code>P</code> 低于算法 2 中的 <code>D</code> 时将不再分配议员，反之后续会弹出优先队列分配议员，这是因为算法 2 中的 <code>D</code> 实际上是题目中议员数不得超过 <code>D</code> 人一个。</p><p>接下来考虑，算法 1 中 <code>Rep[i]=floor(Pop[i]/D)</code> 时</p><p><code>P=Pop[i]/sqrt(Rep[i]*(Rep[i]+1))=Pop[i]/sqrt(floor(Pop[i]/D)*ceil(Pop[i]/D))</code>；</p><p>当 <code>q=Pop[i]/D;q*q&lt;floor(q)*ceil(q)</code> 时，<code>P&lt;Pop[i]/q;P&lt;D</code>，不再分配议员 <code>Rep[i]=floor(Pop[i]/D)</code>，两个算法中结果相同；</p><p>当 <code>q=Pop[i]/D;q*q&gt;floor(q)*ceil(q)</code> 时，<code>P&gt;Pop[i]/q;P&gt;D</code>，会再分配一个议员 <code>Rep[i]=floor(Pop[i]/D)+1=ceil(Pop[i]/D)</code>，两个算法中结果相同。</p><p>当然，考虑某些特殊情况（<code>Pop[i]&lt;D</code>）和边界值（<code>Pop[i] 被 D 整除</code>）结果也是相同的。</p><ol start="4"><li>证明：有可能并不存在正确的 <code>D</code>。即，存在一组 <code>Pop[1 .. n]</code>，<code>n &lt;= R &lt;= P</code>，对于所有的 <code>D &gt; 0</code> 的数字，都不能通过算法 2 得到正确的 <code>reps=R</code>。</li></ol><p><s>「呃，没思路，题目就莫名其妙，难道前面几问都是逗我呢！？！」</s></p><blockquote><p>为了全局，暂时放过这一块，哈哼！</p></blockquote><h2 id="书中的典型案例">书中的典型案例</h2><ul><li>两数相乘</li><li>议员席位分配</li></ul><p>（陆续完善……）</p><h2 id="书中习题">书中习题</h2><p>（陆续完善……）</p><h2 id="同一本书的文章集">同一本书的文章集</h2><ol start="0"><li><a href="scroll-to-the-very-top">回到开头</a></li><li><a href="post:Book-Algorithms-1-Recursion">Recursion</a></li><li><a href="post:Book-Algorithms-2-Backtracking">Backtracking</a></li><li><a href="post:Book-Algorithms-3-Dynamic-Programming">Dynamic Programming</a></li><li><a href="post:Book-Algorithms-4-Greedy-Algorithms">Greedy Algorithms</a></li><li><a href="post:Book-Algorithms-5-Basic-Graph-Algorithms">Basic Graph Algorithms</a></li><li><a href="post:Book-Algorithms-6-Depth-First-Search">Depth-First Search</a></li><li><a href="post:Book-Algorithms-7-Minimum-Spanning-Trees">Minimum Spanning Trees</a></li><li><a href="post:Book-Algorithms-8-Shortest-Paths">Shortest Paths</a></li><li><a href="post:Book-Algorithms-9-All-Pairs-Shortest-Paths">All-Pairs Shortest Paths</a></li><li><a href="post:Book-Algorithms-10-Maximum-Flows-&-Minimum-Cuts">Maximum Flows & Minimum Cuts</a></li><li><a href="post:Book-Algorithms-11-Applications-of-Flows-and-Cuts">Applications of Flows and Cuts</a></li><li><a href="post:Book-Algorithms-12-NP-Hardness">NP-Hardness</a></li></ol><br /><br /><hr /><br /><div class="comments"><a href="mailto:954382491@qq.com?subject=评价「读书笔记之《Algorithms》0」">发邮件~来评价~一下吧</a><h6 class="tip">⚠️ 请先安装一款邮件软件（部分浏览器可能不支持，请使用设备默认浏览器打开本页面）</h6></div><br /></article></div><script type="application/javascript" src="template.7c2a022c86.js"></script></body></html>