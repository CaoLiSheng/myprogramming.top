<!DOCTYPE html><html lang="cn-zh"><head><meta charset="UTF-8" /><meta http-equiv="pragma" content="no-cache" /><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title>读书笔记之《Algorithms》1</title><script> var _hmt = _hmt || []; (function () { var hm = document.createElement('script'); hm.src = 'https://hm.baidu.com/hm.js?f402a68d651d46513a3688a8d07eb93c'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(hm, s); })(); </script><link rel="stylesheet" type="text/css" href="antique.4789c4d0f3.css" /></head><body class="snapshot"><article class="markdown-body hidden"><h1>读书笔记之《Algorithms》1</h1><h6 class="date-tag"><code> ~~ 更新于 -> 2020-10-09</code></h6><blockquote><p>Recursion（递归）</p></blockquote><h2 id="reduction">Reduction（降低复杂度技术）</h2><p>例如，<code>Congressional Apportionment 问题</code> 中 <code>ApportionCongress</code> 算法将问题转化为对 <code>优先队列</code> 的 <code>插入</code> 和 <code>弹出最大优先项</code> 的操作。<code>优先队列</code> 对 <code>ApportionCongress</code> 算法来说是个黑箱，后者无需关心前者的正确性，然而选择合适的实现会影响算法的运行效率，这正是算法分析中的 <code>Why</code> 和 <code>How Fast</code>。</p><h2 id="recursionreduction">Recursion（递归，一种特殊的 Reduction）</h2><ol><li>如果，能直接得到解，则直接解（Base Case）</li><li>否则，将问题拆分为一个或多个更简单的相同的问题（Reduction）</li></ol><h2 id="patterndivideandconquer">Pattern（Divide-And-Conquer）</h2><ol><li><strong>Divide</strong>：把给定的一个规模较大问题分解为一个或多个规模较小的相同问题</li><li><strong>Delegate</strong>：指定每个小问题调用递归方式求解</li><li><strong>Combine</strong>：将每个小问题的解整合起来作为给定问题的解</li></ol><h2 id="recursiontrees">Recursion Trees</h2><p>递归式 <code>T(n)=rT(n/c)+f(n)</code> 的递归树结构可以描述为：共 <code>L=log(c)(n)</code> 层，第 <code>l</code> 层 <code>pow(r, l)</code> 个节点，用时 <code>T'(l)=pow(r, l)*f(n/pow(c, l))</code>，总用时 <code>T(n)=T'(0)+T'(1)+ .. +T'(L)</code>。</p><p>计算总用时，有三种特殊情况：</p><ol><li><code>T'(l)</code> 随着 <code>l</code> 从 <code>0</code> 到 <code>L</code> 其最高阶项的阶 <code>指数级不断减小</code>，则 <code>T(n)=O(T'(0))=O(f(n))</code></li><li><code>T'(l)</code> 随着 <code>l</code> 从 <code>0</code> 到 <code>L</code> 其最高阶项的阶 <code>没有变化</code>，则 <code>T(n)=O(f(n)*L)=O(f(n)*log(c)(n))</code></li><li><code>T'(l)</code> 随着 <code>l</code> 从 <code>0</code> 到 <code>L</code> 其最高阶项的阶 <code>指数级不断增加</code>，则 <code>T(n)=O(T'(L))=O(pow(r, log(c)(n))*f(n0))=O(pow(n, log(c)(r)))</code></li></ol><h2 id="domaintransformations">Domain Transformations</h2><p><strong>作用</strong>：移除求解递归式时的 <code>floors</code>、<code>ceilings</code> 以及<code>低阶项</code>。</p><p>以 <code>MergeSort</code> 为例 <code>T(n) = T(floor(n/2)) + T(ceil(n/2)) + n</code>。</p><ol><li><p>由于目标是计算 <code>T(n)=O(·)</code>，即 <code>上界</code>，所以可以适当放大一下：<code>T(n) &lt;= 2T(ceil(n/2)) + n &lt;= 2T(n/2+1) + n</code></p></li><li><p>定义一个函数 <code>S(n)=T(n+𝛼)</code>，寻找常量 <code>𝛼</code> 使得 <code>S(n) &lt;= 2S(n/2) + O(n)</code></p></li></ol><pre><code class="python language-python">S(n) = T(n+𝛼)
    &lt;= 2T(n/2+𝛼/2+1) + n+𝛼
     = 2S(n/2-𝛼/2+1) + n+𝛼
</code></pre><p>指定 <code>𝛼=2</code>，则 <code>S(n)&lt;=2S(n/2)+n+2=2S(n/2) + O(n)</code>，满足预期</p><ol start="3"><li>通过 <code>递归树方法</code> 可以得出 <code>S(n)&lt;=O(n*log(n))</code>，则 <code>T(n)=S(n-2)&lt;=O((n-2)*log(n-2))=O(n*log(n))</code>，满足预期</li></ol><h2 id="">书中的典型案例</h2><ul><li>汉诺塔</li><li>归并排序</li><li>快速排序</li><li>快速选择第 k 小元素</li><li><code>T(n)&lt;O(pow(n, 2))</code> 的乘法</li><li>计算指数</li></ul><p>（陆续完善……）</p><h2 id="-1">书中习题</h2><p>（陆续完善……）</p><h2 id="-2">同一本书的文章集</h2><ol><li><a href="post:Algorithms-0-Preface-&-Introduction">Preface-&-Introduction</a></li><li><a href="scroll-to-the-very-top">回到开头</a></li><li><a href="post:Algorithms-2-Backtracking">Backtracking</a></li><li><a href="post:Algorithms-3-Dynamic-Programming">Dynamic Programming</a></li></ol><br /><br /><hr /><br /><div class="comments"><a href="mailto:954382491@qq.com?subject=评价「读书笔记之《Algorithms》1」">发邮件~来评价~一下吧</a><h6 class="tip">⚠️ 请先安装一款邮件软件（部分浏览器可能不支持，请使用设备默认浏览器打开本页面）</h6></div><br /></article><script type="application/javascript" src="template.dd6a38f231.js"></script></body></html>