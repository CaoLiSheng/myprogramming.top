<!doctype html><html lang="cn-zh"><head><meta charset="UTF-8"/><meta http-equiv="pragma" content="no-cache"/><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/><meta name="viewport" content="user-scalable=0,width=device-width,initial-scale=1"><title>读书笔记之《Operating System Concepts》3 | 又心真人的博客</title><script> var _hmt = _hmt || []; (function () { var hm = document.createElement('script'); hm.src = 'https://hm.baidu.com/hm.js?f402a68d651d46513a3688a8d07eb93c'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(hm, s); })(); </script><link rel="stylesheet" href="antique.7e5ea10f77.css"/><link rel="icon" href="./favicon.ico"></head><body><div id="article" style="display:none;"><article class="markdown-body"><h1>读书笔记之《Operating System Concepts》3</h1><h6 class="date-tag"><code> ~-~> 2021-01-19</code></h6><blockquote><p>进程</p></blockquote><h2 id="process-concept">Process Concept</h2><p>The status of the current activity of a process is represented by the value of the <code>program counter</code> and the contents of the processor's regitsters. The memory layout of a process is typically divided into multiple sections (from low address to high address):</p><ul><li>Text section--the executable code</li><li>Data section--global variables</li><li>Heap section--memory that is dynamically allocated during program run time</li><li>Stack section--temporary data storage when invoking functions (activation record: such as function parameters, ruturn address, and local variables)</li></ul><p>Although the stack and heap sections grow <em><strong>toward</strong></em> one another, the operating system must ensure they do not <em><strong>overlap</strong></em> one another.</p><h2 id="program-vs-process">Program vs. Process</h2><p>A program is a <em><strong>passive</strong></em> entity, such as a file containing a list of instructions stored on disk (often called an executable file). In contrast, a process is an <em><strong>active</strong></em> entity, with a program counter specifying the next instruction to execute and a set of associated resources. A program becomes a process when an executable file is loaded into memory.</p><h2 id="process-state">Process State</h2><p><figure><div class="image" style="height: auto;" data-scroll-x="0" data-scroll-y="0"><img alt="diagram of process state" src="../resources/Operating-System-Concepts-3-Processes/diagram-of-process-state.png" title="又心真人的博客" width="666px" height="auto" /></div><figcaption>diagram of process state</figcaption></figure></p><h2 id="pcb-code-process-control-block-code-code-task-control-block-code">PCB (<code>process control block</code> / <code>task control block</code>)</h2><ul><li><em><strong>Process state</strong></em>. The state may be new, ready, running, waiting, halted, and so on.</li><li><em><strong>Program counter</strong></em>. The counter indicates the address of the next instruction to be executed for this process.</li><li><em><strong>CPU registers</strong></em>. The registers vary in number and type, depending on the computer architecture. They include accumulators, index registers, stack pointers, and general-purpose registers, plus any condition-code information. Along with the program counter, this state information must be saved when an interrupt occurs, to allow the process to be continued correctly afterward when it is rescheduled to run.</li><li><em><strong>CPU-scheduling information</strong></em>. This information includes a process priority, pointers to scheduling queues, and any other scheduling parameters.</li><li><em><strong>Memory-management information</strong></em>. This information may include such items as the value of the base and limit registers and the page tables, or the segment tables, depending on the memory system used by the operating system.</li><li><em><strong>Accounting information</strong></em>. This information includes the amount of CPU and real time used, time limits, account numbers, job or process numbers, and so on.</li><li><em><strong>I/O status information</strong></em>. This information includes the list of I/O devices allocated to the process, a list of open files, and so on.</li></ul><p>In brief, the PCB simply serves as the repository for all the data needed to start, or restart, a process, along with some accounting data.</p><blockquote><p>Within the Linux kernel, all active processes are represented using a doubly linked list of task_struct. The kernel maintains a pointer-current-to the process currently executing on the system.</p></blockquote><h2 id="process-scheduling-concepts">Process Scheduling Concepts</h2><ul><li><em><strong>degree of multiprogramming</strong></em>. The number of processes currently in memory.</li><li><em><strong>I/O bound process</strong></em>. One kind of process that spends more of its time doing I/O than it spends doing computations.</li><li><em><strong>CPU-bound process</strong></em>. One kind of process that generates I/O requests infrequently, using more of its time doing computations.</li><li><em><strong>ready queue</strong></em>. A queue of process which is ready and wwaiting to execute on a CPU's core.</li><li><em><strong>wait queue</strong></em>. A queue of process which is waiting for a certain event to occur (such as completion of I/O).</li></ul><h2 id="queueing-diagram">Queueing Diagram</h2><p><figure><div class="image" style="height: auto;" data-scroll-x="0" data-scroll-y="0"><img alt="queueing-diagram representation of process scheduling" src="../resources/Operating-System-Concepts-3-Processes/queueing-diagram-representation-of-process-scheduling.png" title="又心真人的博客" width="600px" height="auto" /></div><figcaption>queueing-diagram representation of process scheduling</figcaption></figure></p><h2 id="swapping">Swapping</h2><p>Some operating systems have an intermediate form of scheduling, known as <code>swapping</code>, whose key idea is that sometimes it can be advantageous to remove a process from memory (and from active contention for the CPU) and thus reduce the degree of multiprogramming. Later, the process can be reintroduced into memory, and its execution can be continued where it left off. This scheme is known as <em><strong>swapping</strong></em> because a process can be &quot;swapped out&quot; from memory to disk, where its current status is saved, and later &quot;swapped in&quot; from disk back to memory, where its status is restored. Swapping is typically only necessary when memory has been overcommitted and must be freed up.</p><h2 id="another-copy-of-summary-in-the-book">Another COPY of Summary in the Book</h2><h2 id="bi-ji-mu-lu">笔记目录</h2><ol><li><a href="scroll-to-the-very-top">回到开头</a></li></ol><br /><br /><hr /><br /><div class="comments"><a href="mailto:954382491@qq.com?subject=评价「读书笔记之《Operating System Concepts》3」">来聊两句吧～</a><h6 class="tip">⚠️ 请先安装一款邮件软件（部分浏览器可能不支持，请使用设备默认浏览器打开本页面）</h6></div><br /></article></div><script>var temp = document.getElementById('article'); window.ARTICLE = temp.innerHTML; document.body.removeChild(temp);</script><div id="app"></div><script src="./app~31ecd969.c5fe5167df10ae0529f2.js"></script><script src="./app~55ff73d6.c5fe5167df10ae0529f2.js"></script></body></html>