<!doctype html><html lang="cn-zh"><head><meta charset="UTF-8"/><meta http-equiv="pragma" content="no-cache"/><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/><meta name="viewport" content="user-scalable=0,width=device-width,initial-scale=1"><title>读书笔记之《Operating System Concepts》3 | 又心真人的博客</title><script> var _hmt = _hmt || []; (function () { var hm = document.createElement('script'); hm.src = 'https://hm.baidu.com/hm.js?f402a68d651d46513a3688a8d07eb93c'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(hm, s); })(); </script><link rel="stylesheet" href="antique.75700303f3.css"/><link rel="icon" href="./favicon.ico"></head><body><div id="article" style="display:none;"><article class="markdown-body"><h1>读书笔记之《Operating System Concepts》3</h1><h6 class="date-tag"><code> ~-~> 2021-02-24</code></h6><blockquote><p>进程</p></blockquote><h2 id="process-concept">Process Concept</h2><p>The status of the current activity of a process is represented by the value of the <code>program counter</code> and the contents of the processor's regitsters. The memory layout of a process is typically divided into multiple sections (from low address to high address):</p><ul><li>Text section--the executable code</li><li>Data section--global variables</li><li>Heap section--memory that is dynamically allocated during program run time</li><li>Stack section--temporary data storage when invoking functions (activation record: such as function parameters, ruturn address, and local variables)</li></ul><p>Although the stack and heap sections grow <em><strong>toward</strong></em> one another, the operating system must ensure they do not <em><strong>overlap</strong></em> one another.</p><h2 id="program-vs-process">Program vs. Process</h2><p>A program is a <em><strong>passive</strong></em> entity, such as a file containing a list of instructions stored on disk (often called an executable file). In contrast, a process is an <em><strong>active</strong></em> entity, with a program counter specifying the next instruction to execute and a set of associated resources. A program becomes a process when an executable file is loaded into memory.</p><h2 id="process-state">Process State</h2><p><figure><div class="image" style="height: auto;" data-scroll-x="0" data-scroll-y="0"><img alt="diagram of process state" src="../resources/Operating-System-Concepts-3-Processes/diagram-of-process-state.png" title="又心真人的博客" width="666px" height="auto" /></div><figcaption>diagram of process state</figcaption></figure></p><h2 id="pcb-code-process-control-block-code-code-task-control-block-code">PCB (<code>process control block</code> / <code>task control block</code>)</h2><ul><li><em><strong>Process state</strong></em>. The state may be new, ready, running, waiting, halted, and so on.</li><li><em><strong>Program counter</strong></em>. The counter indicates the address of the next instruction to be executed for this process.</li><li><em><strong>CPU registers</strong></em>. The registers vary in number and type, depending on the computer architecture. They include accumulators, index registers, stack pointers, and general-purpose registers, plus any condition-code information. Along with the program counter, this state information must be saved when an interrupt occurs, to allow the process to be continued correctly afterward when it is rescheduled to run.</li><li><em><strong>CPU-scheduling information</strong></em>. This information includes a process priority, pointers to scheduling queues, and any other scheduling parameters.</li><li><em><strong>Memory-management information</strong></em>. This information may include such items as the value of the base and limit registers and the page tables, or the segment tables, depending on the memory system used by the operating system.</li><li><em><strong>Accounting information</strong></em>. This information includes the amount of CPU and real time used, time limits, account numbers, job or process numbers, and so on.</li><li><em><strong>I/O status information</strong></em>. This information includes the list of I/O devices allocated to the process, a list of open files, and so on.</li></ul><p>In brief, the PCB simply serves as the repository for all the data needed to start, or restart, a process, along with some accounting data.</p><blockquote><p>Within the Linux kernel, all active processes are represented using a doubly linked list of task_struct. The kernel maintains a pointer-current-to the process currently executing on the system.</p></blockquote><h2 id="process-scheduling-concepts">Process Scheduling Concepts</h2><ul><li><em><strong>degree of multiprogramming</strong></em>. The number of processes currently in memory.</li><li><em><strong>I/O bound process</strong></em>. One kind of process that spends more of its time doing I/O than it spends doing computations.</li><li><em><strong>CPU-bound process</strong></em>. One kind of process that generates I/O requests infrequently, using more of its time doing computations.</li><li><em><strong>ready queue</strong></em>. A queue of process which is ready and waiting to execute on a CPU's core.</li><li><em><strong>wait queue</strong></em>. A queue of process which is waiting for a certain event to occur (such as completion of I/O).</li></ul><h2 id="queueing-diagram">Queueing Diagram</h2><p><figure><div class="image" style="height: auto;" data-scroll-x="0" data-scroll-y="0"><img alt="queueing-diagram representation of process scheduling" src="../resources/Operating-System-Concepts-3-Processes/queueing-diagram-representation-of-process-scheduling.png" title="又心真人的博客" width="600px" height="auto" /></div><figcaption>queueing-diagram representation of process scheduling</figcaption></figure></p><h2 id="swapping">Swapping</h2><p>Some operating systems have an intermediate form of scheduling, known as <code>swapping</code>, whose key idea is that sometimes it can be advantageous to remove a process from memory (and from active contention for the CPU) and thus reduce the degree of multiprogramming. Later, the process can be reintroduced into memory, and its execution can be continued where it left off. This scheme is known as <em><strong>swapping</strong></em> because a process can be &quot;swapped out&quot; from memory to disk, where its current status is saved, and later &quot;swapped in&quot; from disk back to memory, where its status is restored. Swapping is typically only necessary when memory has been overcommitted and must be freed up.</p><h2 id="process-creation">Process Creation</h2><p>When a process creates a new process, two possibilities for execution exist:</p><ol><li>The parent continues to execute concurrently with its children.</li><li>The parent waits until some or all of its children have terminated.</li></ol><p>There are also two address-space possibilities for the new process:</p><ol><li>The child process is a duplicate of the parent process (it is the same program and data as the parent).</li><li>The child process has a new program loaded into it.</li></ol><h2 id="process-termination">Process Termination</h2><p>A parent may terminate the execution of one of its children for a variety of reasons, such as these:</p><ol><li>The child has exceeded its usage of some of the resources that it has been allocated. (To determine whether this has occurred, the parent must have a mechanism to inspect the state of its children.)</li><li>The task assigned to the child is no longer required.</li><li>The parent is exiting, and the operating system does not allow a child to continue if its parent terminates.</li></ol><h2 id="android-process-hierarchy">Android Process Hierarchy</h2><p>From most to least important, the hierarchy of process classifications is as follows:</p><div class="table"><table><tbody><tr><td><em><strong>Foreground process</strong></em></td><td><p>The current process visible on the screen, representing the application theuser is currently interacting with</p></td></tr><tr><td><em><strong>Visible process</strong></em></td><td><p>A process that is not directly visible on the foreground but that isperforming an activity that the foreground process is referring to (that is,a process performing an activity whose status is displayed on the foregroundprocess)</p></td></tr><tr><td><em><strong>Service process</strong></em></td><td><p>A process that is similar to a background process but is performing anactivity that is apparent to the user (such as streaming music)</p></td></tr><tr><td><em><strong>Background process</strong></em></td><td>A process that may be performing an activity but is not apparent to the user.</td></tr><tr><td><em><strong>Empty process</strong></em></td><td>A process that holds no active components associated with any application.</td></tr></tbody></table></div><p>If system resources must be reclaimed, Android will first terminate empty processes, followed by background processes, and so forth. Processes are assigned an importance ranking, and Android attempts to assign a process as high a ranking as possible.</p><p>Forthermore, Android development practices suggest following the guidelines of the process life cycle. When these guidelines are followed, the state of a process will be saved prior to termination and resumed at its saved state if the user navigates back to the application.</p><h2 id="process-cooperation">Process Cooperation</h2><p>There are several reasons for providing an environment that allow process cooperation:</p><ul><li><em><strong>Information sharing.</strong></em> Since several applications may be interested in the same piece of information (for instance, coping and pasting), we must provide an environment to allow concurrent access to such information.</li><li><em><strong>Computation speedup.</strong></em> If we want a particular task to run faster, we must break it into subtasks, each of which will be executing in parallel with the others. Notice that such a speedup can be achieved only if the computer has multiple processing cores.</li><li><em><strong>Modularity.</strong></em> We may want to construct the system in a modular fashion, dividing the system functions into seperate processes or threads.</li></ul><h2 id="brief-contrast-of-shared-memory-and-message-passing">Brief Contrast of Shared Memory and Message Passing</h2><p>Both of the models are common in operating systems, and many systems implement both. Message passing is useful for exchanging smaller amounts of data, because no conflicts need be avoided. Message passing is also easier to implement in a distributed system than shared memory. Shared memory can be faster than message passing, since message-passing systems are typically implementedd using system calls and thus require the more time-consuming task of kernel intervention. In shared-memory systems, system calls are required only to establish shared-memory regions. Once shared memory is established, all accesses are treated as routine memory accesses, and no assistance from the kernel is required.</p><h2 id="ipc-in-message-passing">IPC in Message-Passing</h2><p>Here are several methods for logically implementing a link and the <code>send()/receive()</code> operations:</p><ul><li>Direct or indirect communication</li><li>Synchronous or asynchronous communication</li><li>Automatic or explicit buffering</li></ul><h2 id="mach-message-passing">Mach Message Passing</h2><p>When a task is created, two special ports--the <strong>Task Self</strong> port and the <strong>Notify</strong> port--are also created. The kernel has receive rights to the Task Self port, which allows a task to send messages to the kernel. The kernel can send notification of event occurrences to a task's Nofity port (to which, of course, the task has receive rights).</p><p>Each task also has access to a <code>bootstrap port</code>, which allows a task to register a port it has created with a system-wide <code>bootstrap server</code>. Once a port has been registered with the bootstrap server, other tasks can look up the port in this registry and obtain rights for sending messagees to the port.</p><p>Mach messages contain the following two fields:</p><ul><li>A fixed-size message header containing metadata about the message, including the size of the message as well as source and destination ports. Commonly, the sending thread expects a reply, so the port name of the source is passed on to the receiving task, which can use it as a &quot;return address&quot; in sending a reply.</li><li>A variable-sized body containing data.</li></ul><p>The major problem with message systems has generally been poor performance caused by copying of the messages from the sender's port to the receiver's port. The Mach message system attampts to avoid copy operations by using virtual-memory-management techniques. Essentially, Mach maps the address space containing the sender's message into the receiver's address space. Therefore, the message itself is never actually copied,, as both the sender and receiver access the same memory. This message-management technique provides a large performance boost but works only for intrasystem messages.</p><h2 id="alpc-facility-in-windows">ALPC Facility in Windows</h2><p>The message-passing facility in Windows is called the <code>advanced local procedure call (ALPC)</code> facility. It is similar to the standard remote procedure call (RPC) mechanism that is widely used, but it is optimized for and specific to Windows. Like Mach, Windows use a port object to establish and maintain a connection between two processes. Windows uses two types of ports: <code>connection ports</code> and <code>communication ports</code>.</p><p>When an ALPC channel is created, one of three message-passing techniques is chosen:</p><ol><li>For small messages (up to 256 bytes), the port's message queue is used as intermediate storage, and the messages are copied from one process to the other.</li><li>Larger messages must be passed through a <code>section object</code>, which is a region of shared memory associated with the channel.</li><li>When the amount of data is too large to fit into a section object, an API is available that allows server processes to read and write directly into the address space of a client.</li></ol><p>It's important to note that the ALPC facility in Windows is not part of the Windows API and hence is not visible to the application programmer. Rather, applications using the Windows API invoke standard remote procedure calls. When the RPC is being invoked on a process on the same system, the RPC is handled indirectly through an ALPC procedure call. Additionally, many kernel services use ALPC to communicate with client processes.</p><h2 id="pipes">Pipes</h2><p>A <code>pipe</code> acts as a conduit allowing two processes to communicate. Pipes were one of the first IPC mechanisms in early UNIX system. In implementing a pipe, four issues must be considered:</p><ol><li>Does the pipe allow bidirectional communication, or is communication unidirectional?</li><li>If two-way communication is allowed, is it half duplex (data can travel only one way at a time) or full duplex (data can travel in both directions at the same time)?</li><li>Must a relationship (such as parent-child) exist between the communicating processes?</li><li>Can the pipes communicate over a network, or must the communicating processes reside on the same machine?</li></ol><p>Brief contrast between <code>Ordinary Pipes</code> and <code>Named Pipes</code> on <code>UNIX</code> and <code>Windows</code>:</p><ul><li>Ordinary Pipes (termed <code>anonymous pipes</code> on Windows systems) <ul><li>unidirectional</li><li>parent-child relationship</li><li>cease to exist, once the processes have finished communicating and have terminated</li></ul></li><li>Named Pipes <ul><li>bidirectional</li><li>no need for parent-child relationship</li><li>continue to exist, ...</li><li>UNIX <ul><li>half-duplex</li><li>on the same machine</li></ul></li><li>Windows <ul><li>full-duplex</li><li>ability to communicate over a network</li></ul></li></ul></li></ul><h2 id="rp-cs-remote-procedure-calls">RPCs (remote procedure calls)</h2><p>Communication using sockets -- although common and efficient -- is considered a low-level form of communication between distributed processes. One reason is that sockets allow only an unstructured stream of bytes to be exchanged between the communicating threads. It is the responsibility of the client and server application to impose a structure on the data. RPCs is a higher-level method of communication. There are several issues:</p><ul><li>Parameter marshaling addresses the issue concerning differences in data representation on the client and server machines. Many RPC systems define a machine-independent representation of data. One such representation is known as <code>external data representation (XDR)</code>.</li><li>Another important issue involves the semantic of a call. One way to address this problem is for the operating system to ensure that messages are acted on <strong>exactly once</strong>, rather than <strong>at most once</strong>. For <strong>exactly once</strong>, we need to remove the risk that the server will never receive the request. To accomplish this, the server must implement the <strong>at most once</strong>protocol (the server must keep a history of all the timestamps of messages it has already processed, incoming messages that have a timestamp already in the history are ignored) but must also acknowledge to the client that the RPC call was received and executed. The client must resend each RPC call periodically until it receives the ACK for that call.</li><li>Yet another important issue concerns the communication between a server and a cient. Two approaches are common. First, the binding information may be predetermined, in the form of fixed port addresses. Second, binding can be done dynamically by a rendezvous mechanism. Typically, an operating system provides a rendezvous (also called a matchmaker) daemon on a fixed RPC port. Figure below shows a sample interaction.</li></ul><p><figure><div class="image" style="height: auto;" data-scroll-x="0.5" data-scroll-y="0"><img alt="Execution of a remote procedure call (RPC)" src="../resources/Operating-System-Concepts-3-Processes/execution-of-a-remote-procedure-call.png" title="又心真人的博客" width="666px" height="auto" /></div><figcaption>Execution of a remote procedure call (RPC)</figcaption></figure></p><h2 id="another-copy-of-summary-in-the-book">Another COPY of Summary in the Book</h2><ul><li>A process is a program in execution, and the status of the current activity of a process is represented by the program counter, as well as other registers.</li><li>The layout of a process in memory is represented by four different sections: (1)text, (2)data, (3)heap, and (4)stack.</li><li>As a process executes, it changes state. There are four general states of a process: (1)ready, (2)running, (3)waiting, and (4)terminated.</li><li>A process control block (PCB) is the kernel data structure that represents a process in an operating system.</li><li>The role of the process scheduler is to select an available process to run on a CPU.</li><li>An operating system performs a context switch when it switches from running one process to running another.</li><li>The <code>fork()</code> and <code>CreateProcess()</code> system calls are used to create processes on UNIX and Windows systems, respectively.</li><li>When shared memory is used for communication between processes, two (or more) processes share the same region of memory. POSIX provides an API for shared memory.</li><li>Two processes may communicate by exchanging messages with one another using message passing. The Mach operating system uses message passing as its primary form of interprocess communication. Windows provides a form of message passing as well.</li><li>A pipe provides a conduit for two processes to communicate. There are two forms of pipes, ordinary and named. Ordinary pipes are designed for communication between processes that have a parent-child relationship. Named pipes are more general and allow serveral processes to communicate.</li><li>UNIX systems provide ordinary pipes through the <code>pipe()</code> system call. Ordinary pipes have a read end and a write end. A parent process can, for example, send data to the pipe using its write end, and the child process can read it from its read end. Named pipes in UNIX are termed FIFOs.</li><li>Windows systems also provide two forms of pipes -- anonymous and named pipes. Anonymous pipes are similar to UNIX ordinary pipes. They are unidirectional and employ parent-child relationships between teh communicating processes. Named pipes offer a richer form of interprocess communication than the UNIX couterpart, FIFOs.</li><li>Two common forms of client-server communication are sockets and remote procedure calls (RPCs). Sockets allow two processes on different machines to communicate over a network. RPCs abstract the concept of function (procedure) calls in such a way that a function can be invoked on another process that may reside on a seperate computer.</li><li>The Android operating system uses RPCs as a form of interprocess communication using its binder framework.</li></ul><h2 id="bi-ji-mu-lu">笔记目录</h2><ol><li><a href="scroll-to-the-very-top">回到开头</a></li></ol><br /><br /><hr /><br /><div class="comments"><a href="mailto:954382491@qq.com?subject=评价「读书笔记之《Operating System Concepts》3」">来聊两句吧～</a><h6 class="tip">⚠️ 请先安装一款邮件软件（部分浏览器可能不支持，请使用设备默认浏览器打开本页面）</h6></div><br /></article></div><script>var temp = document.getElementById('article'); window.ARTICLE = temp.innerHTML; document.body.removeChild(temp);</script><div id="app"></div><script src="./app~31ecd969.feb28845e985678c218e.js"></script><script src="./app~d2305125.feb28845e985678c218e.js"></script></body></html>