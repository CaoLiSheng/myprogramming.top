<!doctype html><html lang="cn-zh"><head><meta charset="UTF-8"/><meta http-equiv="pragma" content="no-cache"/><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/><meta name="viewport" content="user-scalable=0,width=device-width,initial-scale=1"><title>读书笔记之《Algorithms》7</title><script> var _hmt = _hmt || []; (function () { var hm = document.createElement('script'); hm.src = 'https://hm.baidu.com/hm.js?f402a68d651d46513a3688a8d07eb93c'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(hm, s); })(); </script><link rel="stylesheet" href="antique.d5e39289de.css"/></head><body><div id="article" style="display:none;"><article class="markdown-body"><h1>读书笔记之《Algorithms》7</h1><h6 class="date-tag"><code> ~~ 更新于 -> 2020-11-12</code></h6><blockquote><p>Minimum Spanning Trees（最小展开树）</p></blockquote><h2 id="定义">定义</h2><p>将一个<strong>无向连通加权图</strong>展开成树，最小展开树就是使得权重只和最小的展开树。简单表示下<code>G=(V,E)，w:E-&gt;Real Number =&gt; w(T)=sum(w(e)) where e in T</code>。</p><h2 id="引理">引理</h2><p>假如<strong>无向连通加权图</strong>中各边权重各不相同，则该图有唯一的最小展开树。</p><h3 id="证明">证明</h3><p>设 <code>G</code> 是无向连通加权图且有两颗最小展开树 <code>T</code> 和 <code>T'</code>；</p><p>不同的最小展开树必须包含至少一条另一最小展开树没有的边；所以设 <code>e = min{w(e) | T \ T'}</code> 且 <code>e' = min{w(e') | T' \ T}</code>，且不妨假设 <code>w(e) &lt;= w(e')</code>。</p><p><code>T' + {e}</code>一定包含一个环且传过 <code>e</code>，设 <code>e"</code> 为任一这条环上且不在 <code>T</code> 中的边。</p><p>因为 <code>e" != e</code> 且 <code>e" in T' \ T</code> ，所以 <code>w(e") &gt;= w(e') &gt;= w(e)</code>。</p><p>考虑 <code>T" = T' + e - e"</code>（可能与 <code>T</code> 相同），<code>w(T") = w(T') + w(e) - w(e") &lt;= w(T')</code>。由于 <code>T'</code> 是最小展开树，所以 <code>T"</code> 也是最小展开树。三颗树是相同的，<code>G</code> 的最小展开树是唯一的。</p><h2 id="书中的典型案例">书中的典型案例</h2><p>（陆续完善……）</p><h2 id="书中习题">书中习题</h2><p>（陆续完善……）</p><h2 id="同一本书的文章集">同一本书的文章集</h2><ol start="0"><li><a href="post:Book-Algorithms-0-Preface-&-Introduction">Preface-&-Introduction</a></li><li><a href="post:Book-Algorithms-1-Recursion">Recursion</a></li><li><a href="post:Book-Algorithms-2-Backtracking">Backtracking</a></li><li><a href="post:Book-Algorithms-3-Dynamic-Programming">Dynamic Programming</a></li><li><a href="post:Book-Algorithms-4-Greedy-Algorithms">Greedy Algorithms</a></li><li><a href="post:Book-Algorithms-5-Basic-Graph-Algorithms">Basic Graph Algorithms</a></li><li><a href="post:Book-Algorithms-6-Depth-First-Search">Depth-First Search</a></li><li><a href="scroll-to-the-very-top">回到开头</a></li></ol><br /><br /><hr /><br /><div class="comments"><a href="mailto:954382491@qq.com?subject=评价「读书笔记之《Algorithms》7」">发邮件~来评价~一下吧</a><h6 class="tip">⚠️ 请先安装一款邮件软件（部分浏览器可能不支持，请使用设备默认浏览器打开本页面）</h6></div><br /></article></div><script>var temp = document.getElementById('article'); window.ARTICLE = temp.innerHTML; document.body.removeChild(temp);</script><div id="app"></div><script src="./app~31ecd969.38fbdf68006659c983c0.js"></script><script src="./app~55ff73d6.38fbdf68006659c983c0.js"></script></body></html>