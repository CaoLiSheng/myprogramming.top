<!doctype html><html lang="cn-zh"><head><meta charset="UTF-8"/><meta http-equiv="pragma" content="no-cache"/><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/><meta name="viewport" content="user-scalable=0,width=device-width,initial-scale=1"><title>读书笔记之《Algorithms》3</title><script> var _hmt = _hmt || []; (function () { var hm = document.createElement('script'); hm.src = 'https://hm.baidu.com/hm.js?f402a68d651d46513a3688a8d07eb93c'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(hm, s); })(); </script><link rel="stylesheet" href="antique.73ca44c590.css"/></head><body><div id="article" style="display:none;"><article class="markdown-body"><h1>读书笔记之《Algorithms》3</h1><h6 class="date-tag"><code> ~~ 更新于 -> 2020-11-05</code></h6><blockquote><p>Dynamic Programming（动态规划）</p></blockquote><h2 id="第一个简单的动态规划算法">第一个简单的动态规划算法</h2><p>大学时没上过课，都是闷着自学的；把好多问题都想复杂了，原来用 for 循环迭代填充斐波那契数组就是一个动态规划算法。</p><h3 id="结合快速求解矩阵幂运算（o(log(n))）计算斐波那契数">结合快速求解矩阵幂运算（O(log(n))）计算斐波那契数</h3><figure><img alt="figure 1: 结合快速求解矩阵幂运算（O(log(n))）计算斐波那契数" src="../resources/Algorithms-3-Dynamic-Programming/formula-fabnacci.png" title="figure 1: 结合快速求解矩阵幂运算（O(log(n))）计算斐波那契数" width="200px" height="auto" /><figcaption>figure 1: 结合快速求解矩阵幂运算（O(log(n))）计算斐波那契数</figcaption></figure><p>重点就在左边矩阵的 n 次幂上！通过递归可以将矩阵乘法的次数降到 log(n) 次（第一章中提供了两种两数相乘的参考算法，均用到递归思想）。实际上，迭代用到的基本运算是加法（O(n)，n 为数字位数），而矩阵运算中使用了更为昂贵的乘法（目前最快的两数字乘法运算的时间复杂度为 O(n log(n)，n 为数字位数)，发现于 2019 年）；所不同的是迭代的循环次数为 n，而计算矩阵的幂的递归次数为 log(n)；所以，这个递归算法比迭代算法快一丢丢，时间复杂度为（Ω(n)，理由是 O(n log(n) log(n)) &lt; O(n^2)，如下图所示）。</p><figure><img alt="迭代算法 vs. 递归算法" src="../resources/Algorithms-3-Dynamic-Programming/iterator-vs-recursive-fabnacci.png" title="迭代算法 vs. 递归算法" /><figcaption>迭代算法 vs. 递归算法</figcaption></figure><p>那么接下来在设计递归算法之前，还需要若干步推导。从 <code>figure 1</code> 看出，我们要设计一个函数，返回值可以是一个元组 <code>(F(n-1), F(n))</code>；递归式可以设计为 <code>T(n) = T(n/2) + O(n)</code>，这样效率最高。有了目标，<code>n/2</code> 是特殊情况，不妨从普通情况开始推导：</p><p>首先，这个算法还有一种行向量的表达方式： <img alt="结合快速求解矩阵幂运算（O(log(n))）计算斐波那契数" src="../resources/Algorithms-3-Dynamic-Programming/formula-fabnacci-0.png" title="结合快速求解矩阵幂运算（O(log(n))）计算斐波那契数" width="300px" height="auto" /> ，另外幂运算的特点是 <img alt="矩阵幂运算的特点" src="../resources/Algorithms-3-Dynamic-Programming/formula-fabnacci-1.png" title="矩阵幂运算的特点" width="300px" height="auto" /> 。所以，可以得到 F(n)的计算公式：</p><figure><img alt="figure 2: F(n)的计算公式" src="../resources/Algorithms-3-Dynamic-Programming/formula-fabnacci-2.png" title="figure 2: F(n)的计算公式" width="500px" height="auto" /><figcaption>figure 2: F(n)的计算公式</figcaption></figure><p>有了 <code>figure 2</code> 中这个重要公式后，我们分别假设 <code>n=2t-1,m=t-1</code> 和 <code>n=2t,m=t</code>，得到：</p><figure><img alt="figure 3: (F(2t-1), F(2t))的计算公式" src="../resources/Algorithms-3-Dynamic-Programming/formula-fabnacci-3.png" title="figure 3: (F(2t-1), F(2t))的计算公式" width="500px" height="auto" /><figcaption>figure 3: (F(2t-1), F(2t))的计算公式</figcaption></figure><p>好了，公式部分到此为止，接下来就是代码实现：</p><pre><code class="python language-python"># F(n-1), F(n)
def FastRecFibo(n):
    if n == 0:
        return 1, 0
    if n == 1:
        return 0, 1

    m = math.floor(n / 2)
    hprv, hcur = FastRecFibo(m)         # F(m-1), F(m)

    prev = hprv * hprv + hcur * hcur    # F(2m-1)
    curr = hcur * (hprv + hprv + hcur)  # F(2m)
    next = prev + curr                  # F(2m+1)

    if n % 2 == 0:
        return prev, curr
    else:
        return curr, next
</code></pre><h2 id="pattern（smart-recursion）">Pattern（Smart Recursion）</h2><blockquote><p>Dynamic programming is not about filling in tables. It’s about smart recursion!</p></blockquote><p>动态规划是剔除重复之后的递归算法。开发一个动态规划算法需要经历两个阶段：</p><ol><li><p>将问题用递归的思路解决出来：</p><ul><li>精确描述问题</li><li>用递归思路解决</li></ul></li><li><p>虽然动态规划算法并不是填表格或者数组（像前面的例子，用数学的方法可以简化掉数组），但是由于我们处理的数据大概率是数组或者表格，所以在这个阶段要决定一个递归解决问题的顺序，关系到如何填表格或者数组：</p><ul><li>定位子问题</li><li>确定一种数据结构来存储所有子问题的解，通常是数组或表格</li><li>判断子问题间的依赖关系，画出图，用公式描述</li><li>确定解子问题的顺序：Base Case 最先，然后是依赖 Base Case 的子问题，一直接下去，直到解决最初最顶层的问题；说到顺序，填数组可能容易理解，其实填表格也是一样，一行接着下一行，且往往最后只需要填出一个三角矩阵即可</li><li>分析时间复杂度和空间复杂度</li><li>写下来：往往是有规律可循的</li></ul></li></ol><h2 id="warning（greed-is-stupid）">Warning（Greed is Stupid）</h2><blockquote><p>Greedy algorithms never work! Use dynamic programming instead!</p></blockquote><hr /><blockquote><p>You will not receive any credit for any greedy algorithm, on any homework or exam, even if the algorithm is correct, without a formal proof of correctness.</p></blockquote><hr /><blockquote><p>Whenever you write—or even think—the word “greeDY”, your subconscious is telling you to use DYnamic programming.</p></blockquote><h2 id="一次失败的尝试">一次失败的尝试</h2><p>在 <code>子集和问题</code> 中，如果参数 <code>和</code> 特别大，那么用动态规划时需要填充的表格也会特别大；算法效率明显不高。我看到这里的时候，想能不能用 <code>Map[]</code> 存储来存储，结果失败了。</p><pre><code class="python language-python"># def FastSubsetSum(arr, sum):
#     arrLen = len(arr)
#     S = []
#     for i in range(arrLen + 1):
#         S.append(dict(t0=True))

#     i = arrLen - 1
#     while i &gt;= 0:
#         S[i][] = S[i+1][] or S[i+1][]
#         i -= 1

#     return S[0]['t{}'.format(sum)]
</code></pre><p>所以，有时候回溯比动态规划要好一些：</p><blockquote><p>In the 1967 research memorandum(!) where he proposed memo functions, Donald Michie wrote, “To tabulate values of a function which will not be needed is a waste of space, and to recompute the same values more than once is a waste of time.”</p></blockquote><h2 id="书中的典型案例">书中的典型案例</h2><ul><li>求斐波那契数</li><li>断句分词</li><li>编辑距离</li><li>子集之和</li><li>最大独立点集合（这个坑：有一张无回路的图，也就是一颗树啦；独立点集合就是集合中任何两个点之间没有边相连）</li></ul><p>（陆续完善……）</p><h2 id="书中习题">书中习题</h2><p>（陆续完善……）</p><h2 id="同一本书的文章集">同一本书的文章集</h2><ol start="0"><li><a href="post:Book-Algorithms-0-Preface-&-Introduction">Preface-&-Introduction</a></li><li><a href="post:Book-Algorithms-1-Recursion">Recursion</a></li><li><a href="post:Book-Algorithms-2-Backtracking">Backtracking</a></li><li><a href="scroll-to-the-very-top">回到开头</a></li><li><a href="post:Book-Algorithms-4-Greedy-Algorithms">Greedy Algorithms</a></li><li><a href="post:Book-Algorithms-5-Basic-Graph-Algorithms">Basic Graph Algorithms</a></li><li><a href="post:Book-Algorithms-6-Depth-First-Search">Depth-First Search</a></li><li><a href="post:Book-Algorithms-7-Minimum-Spanning-Trees">Minimum Spanning Trees</a></li><li><a href="post:Book-Algorithms-8-Shortest-Paths">Shortest Paths</a></li><li><a href="post:Book-Algorithms-9-All-Pairs-Shortest-Paths">All-Pairs Shortest Paths</a></li><li><a href="post:Book-Algorithms-10-Maximum-Flows-&-Minimum-Cuts">Maximum Flows & Minimum Cuts</a></li><li><a href="post:Book-Algorithms-11-Applications-of-Flows-and-Cuts">Applications of Flows and Cuts</a></li><li><a href="post:Book-Algorithms-12-NP-Hardness">NP-Hardness</a></li></ol><br /><br /><hr /><br /><div class="comments"><a href="mailto:954382491@qq.com?subject=评价「读书笔记之《Algorithms》3」">发邮件~来评价~一下吧</a><h6 class="tip">⚠️ 请先安装一款邮件软件（部分浏览器可能不支持，请使用设备默认浏览器打开本页面）</h6></div><br /></article></div><script>var temp = document.getElementById('article'); window.ARTICLE = temp.innerHTML; document.body.removeChild(temp);</script><div id="app"></div><script src="./app~31ecd969.6203fe5458a9f87b5d2f.js"></script><script src="./app~55ff73d6.6203fe5458a9f87b5d2f.js"></script></body></html>