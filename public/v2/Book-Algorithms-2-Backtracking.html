<!doctype html><html lang="cn-zh"><head><meta charset="UTF-8"/><meta http-equiv="pragma" content="no-cache"/><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/><meta name="viewport" content="user-scalable=0,width=device-width,initial-scale=1"><title>读书笔记之《Algorithms》2</title><script> var _hmt = _hmt || []; (function () { var hm = document.createElement('script'); hm.src = 'https://hm.baidu.com/hm.js?f402a68d651d46513a3688a8d07eb93c'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(hm, s); })(); </script><link rel="stylesheet" href="antique.b8919ccb71.css"/><link rel="icon" href="./favicon.ico"></head><body><div id="article" style="display:none;"><article class="markdown-body"><h1>读书笔记之《Algorithms》2</h1><h6 class="date-tag"><code> ~~ 更新于 -> 2020-10-12</code></h6><blockquote><p>Backtracking（回溯）</p></blockquote><h2 id="pattern（recursive-brute-force）">Pattern（recursive brute force）</h2><p>回溯算法是建立在递归的基础上的，常用于作出一系列决定。算法的目标就是建立一个递归结构，每次递归调用作出其中的一个决定，这个决定必须与之前作出的决定保持一致性。所以，每次递归都必须携带两类数据：</p><ol><li>还没有处理的数据</li><li>之前作出的决定</li></ol><p>对于第二类数据，要做到尽可能的少，才能提升算法的效率。最后，考虑是否能将这个算法应用于更常规的问题（例如 <strong>寻找中位数</strong> 推广到 <strong>寻找第 k 小数</strong>）。</p><h2 id="推导递归式">推导递归式</h2><p>已知：<code>T(n)=sum(T(0) +...+ T(n-1)) + O(n)</code></p><p>则 <code>T(n-1)=sum(T(0) +...+ T(n-2)) + O(n-1)</code></p><p>两式相减得 <code>T(n) - T(n-1) = T(n-1) + O(n)</code></p><p>整理后即得递归式 <code>T(n)=2T(n-1) + O(n)</code></p><h2 id="书中的典型案例">书中的典型案例</h2><ul><li>N 皇后问题</li><li>游戏树问题（双人棋类游戏，注意两层树节点才构成一个回合）</li><li>子集之和问题</li><li>字母串中单词分割问题</li><li>最长增长子序列（非连续）</li><li>按访问频率优化二叉搜索树</li></ul><p>（陆续完善……）</p><h2 id="书中习题">书中习题</h2><p>（陆续完善……）</p><h2 id="同一本书的文章集">同一本书的文章集</h2><ol start="0"><li><a href="post:Book-Algorithms-0-Preface-&-Introduction">Preface-&-Introduction</a></li><li><a href="post:Book-Algorithms-1-Recursion">Recursion</a></li><li><a href="scroll-to-the-very-top">回到开头</a></li><li><a href="post:Book-Algorithms-3-Dynamic-Programming">Dynamic Programming</a></li><li><a href="post:Book-Algorithms-4-Greedy-Algorithms">Greedy Algorithms</a></li><li><a href="post:Book-Algorithms-5-Basic-Graph-Algorithms">Basic Graph Algorithms</a></li><li><a href="post:Book-Algorithms-6-Depth-First-Search">Depth-First Search</a></li><li><a href="post:Book-Algorithms-7-Minimum-Spanning-Trees">Minimum Spanning Trees</a></li><li><a href="post:Book-Algorithms-8-Shortest-Paths">Shortest Paths</a></li><li><a href="post:Book-Algorithms-9-All-Pairs-Shortest-Paths">All-Pairs Shortest Paths</a></li><li><a href="post:Book-Algorithms-10-Maximum-Flows-&-Minimum-Cuts">Maximum Flows & Minimum Cuts</a></li><li><a href="post:Book-Algorithms-11-Applications-of-Flows-and-Cuts">Applications of Flows and Cuts</a></li><li><a href="post:Book-Algorithms-12-NP-Hardness">NP-Hardness</a></li></ol><br /><br /><hr /><br /><div class="comments"><a href="mailto:954382491@qq.com?subject=评价「读书笔记之《Algorithms》2」">发邮件~来评价~一下吧</a><h6 class="tip">⚠️ 请先安装一款邮件软件（部分浏览器可能不支持，请使用设备默认浏览器打开本页面）</h6></div><br /></article></div><script>var temp = document.getElementById('article'); window.ARTICLE = temp.innerHTML; document.body.removeChild(temp);</script><div id="app"></div><script src="./app~31ecd969.d272d74696e0a7b1c463.js"></script><script src="./app~55ff73d6.d272d74696e0a7b1c463.js"></script></body></html>