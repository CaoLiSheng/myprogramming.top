<!doctype html><html lang="cn-zh"><head><meta charset="UTF-8"/><meta http-equiv="pragma" content="no-cache"/><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/><meta name="viewport" content="user-scalable=0,width=device-width,initial-scale=1"><title>读书笔记之《Algorithms》5</title><script> var _hmt = _hmt || []; (function () { var hm = document.createElement('script'); hm.src = 'https://hm.baidu.com/hm.js?f402a68d651d46513a3688a8d07eb93c'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(hm, s); })(); </script><link rel="stylesheet" href="antique.73ca44c590.css"/></head><body><div id="article" style="display:none;"><article class="markdown-body"><h1>读书笔记之《Algorithms》5</h1><h6 class="date-tag"><code> ~~ 更新于 -> 2020-11-09</code></h6><blockquote><p>Basic Graph Algorithms（图论基础）</p></blockquote><h2 id="基本定义（可能理解有错误，或翻译不准确）">基本定义（可能理解有错误，或翻译不准确）</h2><ul><li>图：一对<strong>顶点</strong>和<strong>边</strong>的集合</li><li>顶点集合：一个非空集合，顶点可以是任何元素，又可以叫做节点</li><li>边集合：顶点对组成的集合</li><li>无向图：边中的两个顶点不分前后顺序</li><li>有向图：边中的两个顶点有前后顺序的</li><li>端点：边中的两个顶点，在有向图中 <code>u-&gt;v</code> ，u 是尾，v 是头</li><li>违例：无向图中禁止相同的一对端点有多于 1 条边，有向图中禁止相同一对头和尾有多于 1 条边；不允许顶点自己与自己成边</li><li>简单图：没有环和平行边的图</li><li>多图（multigraphs）：非简单图</li><li>邻接点：无向图中一条边的两个顶点互为邻接点；一个称为另一个的邻居，反之亦然</li><li>度：无向图中一个顶点的邻居顶点数量</li><li>前节点：有向图中 <code>u-&gt;v</code> ，u 是 v 的前节点</li><li>后节点：有向图中 <code>u-&gt;v</code> ，v 是 u 的后节点</li><li>入度：有向图中一个顶点的前节点数量</li><li>出度：有向图中一个顶点的后节点数量</li><li>子图：顶点集合和边集合都是原图的子集</li><li>适当的子图：原图的子图，但是与原图不同</li><li>遍历：沿着边依次访问顶点的过程</li><li>路径：一次每个顶点只被访问了一次的遍历</li><li>可达：顶点 v 从顶点 u 出发可达指 u 到 v 之间存在一条路径</li><li>连接的：所有顶点间都是可达的</li><li>连接子图（components）：最大连接的子图</li><li>闭合遍历：遍历开始并结束于同一个顶点</li><li>有环图：每个顶点可以组成闭合遍历，且每个顶点只被访问了一次</li><li>无环图：图中任何子图都不是环图，无环图又可以叫做森林</li><li>有向无环图（Dags）：有向图+无环图</li><li>树：连接的无环图，或者其中的一个连接子图</li><li>展开树：将图转化为它的无环子图。当且仅当原图为连接图时才可以展开图。</li><li>展开森林：将图中的各个连接子图展开树组成的森林</li></ul><h2 id="简单举例">简单举例</h2><ul><li>相交图（intersection graph）</li><li>依赖图（depandency graph）</li><li>配置图（configuration graph）</li><li>有限状态自动机（Finite-state automata）</li></ul><h2 id="数据结构">数据结构</h2><h3 id="邻接表（adjacency-list）">邻接表（adjacency list）</h3><p><img alt="邻接表（adjacency list）" src="../resources/Algorithms-5-Basic-Graph/adjacency-list.png" title="邻接表（adjacency list）" width="400px" height="auto" /></p><h3 id="邻接数组（adjacency-array）">邻接数组（adjacency array）</h3><p><img alt="邻接数组（adjacency array）" src="../resources/Algorithms-5-Basic-Graph/adjacency-array.png" title="邻接数组（adjacency array）" width="900px" height="auto" /></p><h3 id="邻接矩阵（adjacency-matrices）">邻接矩阵（adjacency matrices）</h3><p><img alt="邻接矩阵（adjacency matrices）" src="../resources/Algorithms-5-Basic-Graph/adjacency-matrices.png" title="邻接矩阵（adjacency matrices）" width="400px" height="auto" /></p><h2 id="书中的典型案例">书中的典型案例</h2><p>这一章节主要是图论的基础算法，既是基础、又是模板。</p><h3 id="whatever-first-search">Whatever-First Search</h3><pre><code class="python language-python">def WhateverFirstSearch(s):
  put s into the bag
  while the bag is not empty:
    take v from the bag
    if v is not marked:
      mark v
      for each edge vw:
        put w into the bag
</code></pre><ol><li>bag='Stack' <code>-&gt;</code> 'Depth First'</li><li>bag='Queue' <code>-&gt;</code> 'Breadth First'</li><li>bag='Priority Queue' <code>-&gt;</code> 'Best First'<ul><li>最小展开树</li><li>最短路径</li><li>最宽路径（最大流量）</li></ul></li></ol><h3 id="whatever-first-search-all">Whatever-First Search All</h3><pre><code class="python language-python">WFSAll(G):
  for v in G:
    unmark v
  for v in G:
    if v is unmarked:
      WhateverFirstSearch(v)
</code></pre><pre><code class="python language-python">CountComponents(G):
  count = 0
  for v in G:
    unmark v
  for v in G:
    if v is unmarked:
      count += 1
      WhateverFirstSearch(v)
  return count
</code></pre><h2 id="书中习题">书中习题</h2><p>（陆续完善……）</p><h2 id="同一本书的文章集">同一本书的文章集</h2><ol start="0"><li><a href="post:Book-Algorithms-0-Preface-&-Introduction">Preface-&-Introduction</a></li><li><a href="post:Book-Algorithms-1-Recursion">Recursion</a></li><li><a href="post:Book-Algorithms-2-Backtracking">Backtracking</a></li><li><a href="post:Book-Algorithms-3-Dynamic-Programming">Dynamic Programming</a></li><li><a href="post:Book-Algorithms-4-Greedy-Algorithms">Greedy Algorithms</a></li><li><a href="scroll-to-the-very-top">回到开头</a></li><li><a href="post:Book-Algorithms-6-Depth-First-Search">Depth-First Search</a></li><li><a href="post:Book-Algorithms-7-Minimum-Spanning-Trees">Minimum Spanning Trees</a></li><li><a href="post:Book-Algorithms-8-Shortest-Paths">Shortest Paths</a></li><li><a href="post:Book-Algorithms-9-All-Pairs-Shortest-Paths">All-Pairs Shortest Paths</a></li><li><a href="post:Book-Algorithms-10-Maximum-Flows-&-Minimum-Cuts">Maximum Flows & Minimum Cuts</a></li><li><a href="post:Book-Algorithms-11-Applications-of-Flows-and-Cuts">Applications of Flows and Cuts</a></li><li><a href="post:Book-Algorithms-12-NP-Hardness">NP-Hardness</a></li></ol><br /><br /><hr /><br /><div class="comments"><a href="mailto:954382491@qq.com?subject=评价「读书笔记之《Algorithms》5」">发邮件~来评价~一下吧</a><h6 class="tip">⚠️ 请先安装一款邮件软件（部分浏览器可能不支持，请使用设备默认浏览器打开本页面）</h6></div><br /></article></div><script>var temp = document.getElementById('article'); window.ARTICLE = temp.innerHTML; document.body.removeChild(temp);</script><div id="app"></div><script src="./app~31ecd969.deadda5d9f0a9af53b1f.js"></script><script src="./app~55ff73d6.deadda5d9f0a9af53b1f.js"></script></body></html>